import{_ as e}from"./chunks/urr.ea4dbc36.js";import{_ as t,c as a,o,O as n}from"./chunks/framework.8e4cc2b6.js";const i="/images/guide/pingpong/enter_chatbot.png",s="/images/guide/pingpong/create_entity.png",r="/images/guide/pingpong/pingpong_entity_instance.png",l="/images/guide/pingpong/pingpong_entity_expression.png",c="/images/guide/pingpong/intent_label.png",d="/images/guide/pingpong/add_slot.png",h="/images/guide/pingpong/always_ask.png",p="/images/guide/pingpong/add_prompt.png",g="/images/guide/pingpong/add_name.png",u="/images/guide/pingpong/pingpong_expression.png",y="/images/guide/pingpong/add_response.png",m="/images/guide/pingpong/pingpong_simple_reply.png",L=JSON.parse('{"title":"Build a simple chatbot","description":"","frontmatter":{},"headers":[],"relativePath":"guide/build-simple-chatbot.md","lastUpdated":1682308101000}'),f={name:"guide/build-simple-chatbot.md"},b=n('<h1 id="build-a-simple-chatbot" tabindex="-1">Build a simple chatbot <a class="header-anchor" href="#build-a-simple-chatbot" aria-label="Permalink to &quot;Build a simple chatbot&quot;">​</a></h1><p>This tutorial will guide you step-by-step through the process of building the same chatbot you played within the last guide. After completing this tutorial, you will be able to develop a <a href="./../essentials/5levels-cui.html#frame-with-slots">level 2</a> conversational experience, which is sufficient for allowing users to check your business hours or make a reservation. But let&#39;s start with a bit of background, as you will be using a new and more effective approach to build the chatbot.</p><h2 id="background" tabindex="-1">Background <a class="header-anchor" href="#background" aria-label="Permalink to &quot;Background&quot;">​</a></h2><p>A chatbot is an application with a conversational user interface (CUI). It is developed to provide user services, including answering informational questions and completing transactional tasks. A service is an interface for a business capability that usually consists of a set of Application Programming Interface (API) functions. These interfaces decouple the front end, like the chatbot, from the backend implementation of the service, so that they can be developed independently.</p><p>In order to invoke API functions in a conversational manner, the chatbot needs to create an instance of a function type through conversations, which implies that chatbot also needs to create instances for the input parameters of the function or attributes of composite types in a more general sense.</p><p>A type is considered conversationally exposed if the chatbot knows how to create an instance of it conversationally, potentially in multiple turns. This suggests a different approach to building chatbots: identify the API function types that you want to expose to users, and make these types, as well as all of their dependent types (both direct and indirect), conversationally exposed.</p><p>A type-based chatbot with multiple language support can then function in the following way:</p><ol><li><strong>Convert the user&#39;s utterance into an event</strong>. Here, an event is a way of representing the meaning of a user&#39;s utterance in a language-independent way.</li><li><strong>Given the event and the current dialog state, generate a dialog act</strong>. A dialog act is also a language-independent representation of meaning. It is generated by following interaction logic that greedily tries to complete the instantiation of the function type. Once a function object is created, the chatbot can invoke it and wrap the function return in a dialog act.</li><li><strong>Render the dialog act back to the user in natural language</strong>.</li></ol><p>The same concept is also illustrated here.</p><p><img src="'+e+'" alt="create save"></p><h4 id="a-proper-type-system" tabindex="-1">A proper type system <a class="header-anchor" href="#a-proper-type-system" aria-label="Permalink to &quot;A proper type system&quot;">​</a></h4><p>OpenCUI is designed to support most APIs that can be defined by OpenAPI, which is a widely used standard for documenting RESTful APIs. This means that you can conversationally expose not only to primitive types like Int and String, but also to arrays and user-defined types with polymorphism support. This makes it easy to build conversational interfaces for arbitrary service APIs. In OpenCUI, functions are represented by skills, user-defined types are represented by frames, and primitive types are represented by entities.</p><p>Types declared in OpenCUI can be either internal or external. For internal types, OpenCUI generates a Kotlin class, while for external types, it uses existing Java/Kotlin types, ensuring that every type has a direct representation at the Java/Kotlin level. This allows users to tap into the vast Java ecosystem and leverage any available functionality, as well as use Kotlin code expressions to directly express logic.</p><h4 id="build-chatbot-in-3-layers" tabindex="-1">Build chatbot in 3 layers <a class="header-anchor" href="#build-chatbot-in-3-layers" aria-label="Permalink to &quot;Build chatbot in 3 layers&quot;">​</a></h4><p>OpenCUI promotes a type-based approach to build conversational user interface, by introducing a set of dialog annotations that you can add to the type and its slots. For each composite type that you need to expose conversationally:</p><ol><li><strong>Declare the type at the schema layer</strong>. This includes the label of the type, the slots that are associated with the type, and the local functions and services that are available to the type.</li><li><strong>Add dialog annotations, and configure them in the interaction layer</strong>. The interaction layer determines the language-independent aspects of the conversational interactions: whether the chatbot should ask the user to fill a slot, whether to provide a candidate list, and whether to confirm with the user when a value is received.</li><li><strong>For each language you want to support, configure annotations in required language layer</strong>. The annotations in the language layer help dialog understanding module to map the text in the target language to structured semantics and back. For example, if you are creating a chatbot that supports English and Chinese, you will need to configure language layer annotations for both languages.</li></ol><p>The primitive types, or entities, can be defined in only two layers: schema and language.</p><p>Clearly, a chatbot always consists of many types, and the order in which these types are defined matters. It is important to ensure that all the required types are defined before they are referenced, in order to avoid any circular dependencies or reference errors.</p><h5 id="annotate-a-composite-type" tabindex="-1">Annotate a composite type <a class="header-anchor" href="#annotate-a-composite-type" aria-label="Permalink to &quot;Annotate a composite type&quot;">​</a></h5><p>It is common for composite types to have slots, and then you have to decide whether you want to follow a layer-first or slot-first approach to annotate such types. In this series of quickstart guides, annotation will be added in a slot-first, or one-slot-at-a-time approach, making it easy for you to follow:</p><ol><li>Repeat the following steps for each slot: <ol><li>Add all annotations needed for that slot, and configure them in the interaction layer.</li><li>Configure annotations in the language layer.</li></ol></li><li>Add the type level annotation, in both layers.</li><li>If the type is a skill, configure the response for it, in both layers.</li></ol><h2 id="before-you-start" tabindex="-1">Before you start <a class="header-anchor" href="#before-you-start" aria-label="Permalink to &quot;Before you start&quot;">​</a></h2><ul><li><a href="./signingup.html#sign-up">Sign up</a> for an account and log in to <a href="https://build.opencui.io/login" target="_blank" rel="noreferrer">OpenCUI</a>.</li><li>We assume that you have finished <a href="./clone-simple-chatbot.html">clone a simple chatbot</a>, so you get some idea of what to build.</li></ul><h2 id="create-chatbot-pingpong" tabindex="-1">Create chatbot: pingpong <a class="header-anchor" href="#create-chatbot-pingpong" aria-label="Permalink to &quot;Create chatbot: pingpong&quot;">​</a></h2><p>You can create a chatbot under any organization, following these steps:</p><ol><li>Within an organization, in the upper right corner of the project area, click <strong>Create</strong> and select <strong>Create chatbot</strong>.</li><li>In the pop-up window, complete the form for chatbot basic settings and click <strong>Create</strong>. For this simple chatbot, you only need to fill in the following three fields: <ul><li><strong>Project label</strong>: the unique identifier for the chatbot. Type a short, memorable label for your chatbot. We suggest using a lowercase label. For example, <code>pingpong</code>.</li><li><strong>Region</strong>: where you want to deploy this chatbot. Ideally, it should be close to your users.</li><li><strong>Languages</strong>: the languages your chatbot supports, you can add multiple languages. Multilingual chatbots assume you deliver the same service to each user in their native languages.</li></ul></li></ol><div class="warning custom-block"><p class="custom-block-title">Caution: Project label and region are immutable.</p><p>Choose your project label and region carefully, because you cannot change them after creation. You can, however, clone and rename a project. When you do this, the connections and user session data for the project will not be cloned, for privacy reasons.</p></div><p>If the chatbot is created successfully, it should be displayed in the organization&#39;s project list.</p><p><img src="'+i+'" alt="enter chatbot"></p><h2 id="build-types" tabindex="-1">Build types <a class="header-anchor" href="#build-types" aria-label="Permalink to &quot;Build types&quot;">​</a></h2><p>Under type-based chatbot development, building a chatbot can be achieved by defining every type required by it in a &quot;least dependencies first&quot; approach. The conversational experience you will create in this guide requires a dependent entity type called &#39;Location&#39; and a skill called &#39;PingPong&#39;.</p><h3 id="build-entity-location" tabindex="-1">Build entity: Location <a class="header-anchor" href="#build-entity-location" aria-label="Permalink to &quot;Build entity: Location&quot;">​</a></h3><p>The most basic type in OpenCUI is &quot;entity&quot;. It is a primitive type that the chatbot knows how to extract the value of from the user&#39;s utterance. OpenCUI provides many predefined entities, such as <code>java.time.LocalDate</code> for dates, <code>io.opencui.core.Email</code> for email addresses, and so on. In this case, let&#39;s build a custom entity type <code>Location</code> in schema layer and language layer as follows.</p><h4 id="create-entity-type-location" tabindex="-1">Create entity type: Location <a class="header-anchor" href="#create-entity-type-location" aria-label="Permalink to &quot;Create entity type: Location&quot;">​</a></h4><p>Inside the <code>pingpong</code> chatbot and <strong>Types</strong> page, under the <strong>Structure</strong> view.</p><ol><li>Click <strong>Create</strong> button on the right side, and select <strong>Create entity</strong> to create a new entity.</li><li>Enter a label for the entity type and press enter. For example, <code>Location</code>.</li></ol><h4 id="schema-layer-add-instances" tabindex="-1">Schema layer: add instances <a class="header-anchor" href="#schema-layer-add-instances" aria-label="Permalink to &quot;Schema layer: add instances&quot;">​</a></h4><p>You are required to provide a language-independent label for each instance. One reason for this is to ensure that you can reference them in the interaction logic and make the conversational experience language independent.</p><p>Inside the <code>Location</code> entity and <strong>Instances</strong> tab, under the <strong>Structure</strong> view.</p><p>For each instance you want to add:</p><ol><li>Click <strong>Add</strong> button to add an instances;</li><li>Fill the <strong>Label</strong> field in the pop-up window, for example <code>seattle</code> or <code>paloAlto</code>, and save it.</li></ol><p><img src="'+s+'" alt="create entity"></p><div class="tip custom-block"><p class="custom-block-title">Always propagate changes made under the Structure view to the Languages before beginning work on the Language layer</p><ul><li>Both schema layer and interaction layer are defined under <strong>structure view</strong>, but language layer is under <strong>corresponding language view</strong>. For example, for English, it should be under &quot;Language/en&quot;.</li><li>When you make changes to the Structure view, those changes are NOT automatically propagated to the Language layer. You need to manually propagate the changes by clicking <strong>Propagate</strong> in the top-right corner of the Structure view.</li><li>Once you have propagated the changes, you can switch to the corresponding Language view to work on the language-specific aspects of your project.</li></ul></div><h4 id="language-layer-add-expressions" tabindex="-1">Language layer: add expressions <a class="header-anchor" href="#language-layer-add-expressions" aria-label="Permalink to &quot;Language layer: add expressions&quot;">​</a></h4><p>To enable the chatbot to create instances for an entity type based on user mentions, you must enumerate common expressions for each instance of the user-defined entity type that was added in the previous step.</p><h5 id="expressions-for-instance" tabindex="-1">Expressions for instance <a class="header-anchor" href="#expressions-for-instance" aria-label="Permalink to &quot;Expressions for instance&quot;">​</a></h5><p>Inside the <strong>Location</strong> entity and <strong>Instances</strong> tab, under the <strong>Language/en</strong> view.</p><p>For each instance, you need to enumerate the common expressions that might refer to the instance:</p><ol><li>Click on the instance you want to add expressions to;</li><li>Add expressions into <strong>Expressions</strong> field in the pop-up window, for example, <code>Palo Alto</code> for <code>paloAlto</code>, then save it.</li></ol><p><img src="'+r+'" alt="PingPong add entity instance expression"></p><h5 id="names-for-type" tabindex="-1">Names for type <a class="header-anchor" href="#names-for-type" aria-label="Permalink to &quot;Names for type&quot;">​</a></h5><p>You need to provide the expression of the entity type itself in the form of names. Names are language-dependent representations of the entity type, and they will be used for both detecting mentions of this type from the user&#39;s utterance and displaying the use of this type to the user. Note this need to be done for every type.</p><p>Inside the <code>Location</code> entity and <strong>Expression</strong> tab, under the <strong>Language/en</strong> view.</p><ol><li>In the <strong>Names</strong> section, enter <code>location</code> for the Location entity and press enter.</li></ol><p><img src="'+l+'" alt="PingPong add entity expression"></p><h3 id="build-skill-pingpong" tabindex="-1">Build skill: PingPong <a class="header-anchor" href="#build-skill-pingpong" aria-label="Permalink to &quot;Build skill: PingPong&quot;">​</a></h3><p>Conceptually, a skill is a function exposed in a conversational manner, with input parameters represented by its slots. In this tutorial, you will construct a basic skill called &quot;PingPong&quot; that has a single slot of type &quot;Location&quot;. Once an instance of this function type is created, the chatbot will respond with an acknowledgment in the form of <code>pong to ${location}</code>.</p><h4 id="schema-layer-declare-a-skill" tabindex="-1">Schema layer: declare a skill <a class="header-anchor" href="#schema-layer-declare-a-skill" aria-label="Permalink to &quot;Schema layer: declare a skill&quot;">​</a></h4><p>At this layer, you will create the skill and add all its slots that represent input parameters for the corresponding function. Although not necessary for this particular simple skill, this layer is also where you can declare any required local functions and services, and implement these native local functions as well.</p><h5 id="create-the-skill" tabindex="-1">Create the skill <a class="header-anchor" href="#create-the-skill" aria-label="Permalink to &quot;Create the skill&quot;">​</a></h5><p>Inside the <code>pingpong</code> chatbot and <strong>Types</strong> page, under the <strong>Structure</strong> view.</p><ol><li><p>Click <strong>Create</strong> button on the right side, and select <strong>Create skill</strong> to create a new skill.</p></li><li><p>Enter a label for the skill and press enter. For example, <code>PingPong</code>.</p><div class="tip custom-block"><p class="custom-block-title">Need to know</p><p>In OpenCUI, a label is an identifier that is independent of the language used. The skill label, being a type of label, should follow these guidelines:</p><ul><li>It should start with a capital letter.</li><li>It should be between 2 and 100 characters long.</li><li>It should only contain letters, digits, and underscores.</li></ul></div><p><img src="'+c+'" alt="intent label"></p></li></ol><h5 id="add-slots" tabindex="-1">Add slots <a class="header-anchor" href="#add-slots" aria-label="Permalink to &quot;Add slots&quot;">​</a></h5><p>Inside the <code>PingPong</code> skill and <strong>Schema</strong> tab, under the <strong>Structure</strong> view.</p><ol><li>Click add slot, select the type you want to add as slot in the <strong>Slots</strong> section. In this case, select entity type <code>Location</code>.</li><li>Pick a label for the slot, in this case let&#39;s use <code>location</code>, so that you can reference it in the response.</li></ol><p><img src="'+d+'" alt="add slot"></p><h4 id="annotate-type-pingpong" tabindex="-1">Annotate type: PingPong <a class="header-anchor" href="#annotate-type-pingpong" aria-label="Permalink to &quot;Annotate type: PingPong&quot;">​</a></h4><p>Let&#39;s annotate <code>PingPong</code> skill following <a href="#annotate-a-composite-type">this guide</a>. You will only configure it for &quot;Language/en&quot;, but the configuration for other languages should be identical.</p><h5 id="add-slot-level-annotations-to-location" tabindex="-1">Add slot level annotations to location <a class="header-anchor" href="#add-slot-level-annotations-to-location" aria-label="Permalink to &quot;Add slot level annotations to location&quot;">​</a></h5><p>In case the user did not tell chatbot which location is he from in the initial utterance, the chatbot needs to prompt the user for that information. To do this, you need to select <strong>Always ask</strong> for <a href="./../reference/annotations/fillstrategy.html">fill strategy</a> for this slot. This will make the <strong>Prompt</strong> field required, and you will need to add at least one template to it.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>What needs to be configured in the language layer are decided by the decisions you made at the interaction layer.</p></div><h6 id="interaction-layer" tabindex="-1">Interaction layer <a class="header-anchor" href="#interaction-layer" aria-label="Permalink to &quot;Interaction layer&quot;">​</a></h6><p>Inside the <code>PingPong/location</code> slot and <strong>Annotation</strong> tab, under the <strong>Structure</strong> view.</p><ol><li>Select <strong>Always ask</strong> in the <strong>Fill strategy</strong> section.</li></ol><p><img src="'+h+'" alt="define fill strategy"></p><h6 id="language-layer" tabindex="-1">Language layer <a class="header-anchor" href="#language-layer" aria-label="Permalink to &quot;Language layer&quot;">​</a></h6><p>Inside the <code>PingPong/location</code> slot, under the <strong>Language/en</strong> view.</p><ol><li><p>Fill templates for Prompt.</p><ul><li>Under the <strong>Annotation</strong> tab.</li><li>Enter the sentences in <strong>Prompts</strong> section. For example, <code>Wow. Where is the &quot;ping&quot; coming from?</code>.</li></ul><p><img src="'+p+'" alt="add prompt"></p></li><li><p>Add names for <code>location</code> slot.</p><ul><li>Under the <strong>Expression</strong> tab.</li><li>Enter the names in <strong>Names</strong> section, such as <code>Location</code>.</li></ul><p><img src="'+g+'" alt="add prompt"></p></li></ol><h5 id="add-type-level-annotation" tabindex="-1">Add type level annotation <a class="header-anchor" href="#add-type-level-annotation" aria-label="Permalink to &quot;Add type level annotation&quot;">​</a></h5><p>For this simple skill, only two type level annotations: names, utterance exemplars, are required. Both only need to be configured at language layer. If a user&#39;s utterance is semantically similar to any of the exemplars entered here, it will be considered as an intention to trigger this skill. OpenCUI dialog understanding (DU) module are large language model based, so you do not need to enumerate all possible different utterances that can imply this skill. You just need to add some representative one, or the ones that was understood wrong so that DU can hot fix it.</p><h6 id="language-layer-1" tabindex="-1">Language layer <a class="header-anchor" href="#language-layer-1" aria-label="Permalink to &quot;Language layer&quot;">​</a></h6><p>Inside the <code>PingPong</code> skill and the <strong>Expression</strong> tab, under the <strong>Language/en</strong> view.</p><ol><li>Add expression for <code>PingPong</code> skill: <ul><li>In the <strong>Expressions</strong> section, enter <code>ping</code> and press enter.</li></ul></li><li>Add names for <code>PingPong</code> skill: <ul><li>In the <strong>Names</strong> section, enter <code>Ping Pong</code> for the PingPong skill display name and press enter.</li></ul></li></ol><p><img src="'+u+'" alt="PingPong expression"></p><h4 id="configure-response" tabindex="-1">Configure response <a class="header-anchor" href="#configure-response" aria-label="Permalink to &quot;Configure response&quot;">​</a></h4><p>After being triggered, the PingPong skill responds a <em>&quot;pong&quot;</em> based on the location provided by the user, this behavior is controlled by a response. Responses are executed after the chatbot has all the slots filled per interaction logic defined by attached dialog annotations. In reality, chatbot should call out the service APIs and render the return back to user in natural text. It is often necessary to reference slots and function values in the response. In OpenCUI, this can be easily achieved using <code>${}</code> with arbitrary Kotlin code expression inside.</p><h5 id="interaction-layer-1" tabindex="-1">Interaction layer <a class="header-anchor" href="#interaction-layer-1" aria-label="Permalink to &quot;Interaction layer&quot;">​</a></h5><p>Inside the <code>PingPong</code> skill and the <strong>Response</strong> tab, under the <strong>Structure</strong> view.</p><ol><li>Select <strong>Single value message</strong> under the <strong>Default action</strong> section to declare a simple reply.</li></ol><p><img src="'+y+'" alt="add response"></p><h5 id="language-layer-2" tabindex="-1">Language layer <a class="header-anchor" href="#language-layer-2" aria-label="Permalink to &quot;Language layer&quot;">​</a></h5><p>Inside the <code>PingPong</code> skill and the <strong>Responses</strong> tab, under the <strong>Language/en</strong> view.</p><ol><li>Enter <code>Great! Pong to ${location?.expression()}.</code> in the <strong>Single value message</strong> field and press enter.</li></ol><p><img src="'+m+'" alt="PingPong simple reply"></p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>To render a slot value in a language dependent fashion, use <code>${location?.expression()}</code> instead of <code>${location}</code> which will be rendered to a language independent label.</p></div><h2 id="test-a-chatbot" tabindex="-1">Test a chatbot <a class="header-anchor" href="#test-a-chatbot" aria-label="Permalink to &quot;Test a chatbot&quot;">​</a></h2><p>Before you start testing your newly defined chatbot using the built-in <strong>Debug</strong> tool, click <strong>Commit</strong> in the upper-right corner to commit your changes in the language layer. Keep in mind that Debug can only be used to test committed content for current language, as per <a href="./opencui-flow.html#commit-the-changes">OpenCUI workflow</a>.</p>',97),w=[b];function v(k,P,x,q,I,_){return o(),a("div",null,w)}const T=t(f,[["render",v]]);export{L as __pageData,T as default};
