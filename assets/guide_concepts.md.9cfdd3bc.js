import{_ as e}from"./chunks/relationship.b613a4aa.js";import{_ as t,c as a,o as n,O as o}from"./chunks/framework.8e4cc2b6.js";const y=JSON.parse('{"title":"Key concepts","description":"","frontmatter":{},"headers":[],"relativePath":"guide/concepts.md","lastUpdated":1682308075000}'),i={name:"guide/concepts.md"},s=o('<h1 id="key-concepts" tabindex="-1">Key concepts <a class="header-anchor" href="#key-concepts" aria-label="Permalink to &quot;Key concepts&quot;">​</a></h1><p>OpenCUI is a platform for chatbot builder to build and manage type-based chatbots. Here are the key concepts for building chatbots on OpenCUI.</p><h4 id="organization" tabindex="-1">Organization <a class="header-anchor" href="#organization" aria-label="Permalink to &quot;Organization&quot;">​</a></h4><p>There are two kinds of accounts on the OpenCUI, personal account and organization account. Organization account is like a container for your team&#39;s shared work, and it also manages each person&#39;s access to these shared work. Each person will have their own personal OpenCUI account. People can collaborate on projects by joining the hosting organization account.</p><h4 id="projects" tabindex="-1">Projects <a class="header-anchor" href="#projects" aria-label="Permalink to &quot;Projects&quot;">​</a></h4><p>Projects are the basic unit of work on OpenCUI. Builder can decide whether their projects are public or private. Projects can be copied (cloned) or imported. There are three types of projects: chatbots, modules and providers. Here is a diagram for how they are typically used together to provide conversational experience:</p><p><img src="'+e+'" alt="relationship"></p><h5 id="chatbots" tabindex="-1">Chatbots <a class="header-anchor" href="#chatbots" aria-label="Permalink to &quot;Chatbots&quot;">​</a></h5><p>A chatbot is an application that provides services to users through a conversational user interface (CUI). A service is an interface for a business capability that usually consists of a set of Application Programming Interface(API) functions. These interfaces decouple the client from the provider, allowing software to be developed independently and reused across various applications and systems.</p><p>In order to invoke API functions in a conversational manner, the chatbot needs to create an instance of a function type through conversations, which implies that chatbot also needs to create instances for the input parameters of the function or attributes of composite types in a more general sense.</p><p>To help the chatbot create instances for arbitrary types, OpenCUI allows builders to add dialog annotations to types. From this perspective, a chatbot is essentially a set of dialog annotated types, including skills, frames, dialog acts, entities, and services.</p><h5 id="modules" tabindex="-1">Modules <a class="header-anchor" href="#modules" aria-label="Permalink to &quot;Modules&quot;">​</a></h5><p>Modules are reusable conversational components. For example, a CUI date picker is a simple module that gets the user&#39;s preferred date. Modules can be combined to form larger modules for more complex use cases, or they can be imported into the chatbot to add new conversational functionalities.</p><h5 id="providers" tabindex="-1">Providers <a class="header-anchor" href="#providers" aria-label="Permalink to &quot;Providers&quot;">​</a></h5><p>A service can have one or more providers that connect the chatbot to the backend implementation for its functionalities. Providers can be shared by different chatbots in the same organization. OpenCUI supports three types of providers: PostgreSQL (OpenCUI hosted), RESTful, and native providers.</p><h4 id="type-systems" tabindex="-1">Type systems <a class="header-anchor" href="#type-systems" aria-label="Permalink to &quot;Type systems&quot;">​</a></h4><p>Services can be described by their schema, using description languages such as <a href="https://swagger.io/docs/specification/data-models/" target="_blank" rel="noreferrer">OpenAPI</a>. Such language requires a type system because APIs involve the exchange of data between different systems or components, and data types provide a way to ensure that the exchanged data is well-formed, consistent, and interoperable. OpenCUI&#39;s type system supports not only primitive types and enums, but also lists and user-defined types with polymorphism support, making it easy to build conversational interfaces for arbitrary services.</p><p>To invoke a function through conversations, we need to create an object of that function&#39;s type. To do this, OpenCUI allows you to define CUI types (also known as components), such as skills (think of functions), frames (needed by their parameters), and entities (primitive types), in three steps. First, declare the type and its component, which will be mapped to the hosting language&#39;s data types (currently Java/Kotlin) so that they can be used to invoke service functions. Second, use dialog annotations to define interaction logic. Lastly, use exemplars and templates to control how natural text is converted to structured representation, and vice versa.</p><h5 id="skills" tabindex="-1">Skills <a class="header-anchor" href="#skills" aria-label="Permalink to &quot;Skills&quot;">​</a></h5><p>Generally, a skill is essentially a function that a user can access through conversations. As a CUI data type for functions, it is designed to define a self-contained conversational component that delivers some functionality to a user. This means that all three aspects of conversational service delivery need to be defined on top of the corresponding data type:</p><ol><li>Collect what the user wants through slot filling. You can add slots in the <strong>Slots</strong> section of a skill.</li><li>Invoke functions using the collected slot value as an input parameter. The invoked function can be a native function defined in the current skill, or a function from the slot of the current skill, in a nested sense like <code>slot.function()</code>. You can add service slots in the <strong>Services</strong> section of a skill.</li><li>Verbalize the service result and render it in the channel.</li></ol><p>At the language level, skills can be expressed mainly by verb phrases or full sentences. When expressed in a full sentence, the subject needs to be in the first person. Examples of such utterances include: <em>&quot;Book me a table for two for Sunday evening&quot;</em> or <em>&quot;I would like to make a reservation on Sunday&quot;</em>.</p><h5 id="frames" tabindex="-1">Frames <a class="header-anchor" href="#frames" aria-label="Permalink to &quot;Frames&quot;">​</a></h5><p>In OpenCUI, a frame is a standard object-oriented class type with support for composition and polymorphism behaviors. Frames typically map to parameter types for your function at schema level.</p><p>With inheritance, we can easily support conversations like <em>&quot;What symptoms do you have?&quot;</em> by defining an interface symptom frame and multiple concrete frames, each for an actual symptom. Since each concrete frame can have different interaction logic, when we try to fill an interface Frame slot, we can naturally get the conversational experience we need.</p><p>At the language level, a Frame represents objects with properties and is typically expressed in a noun phrase such as <em>&quot;large, spicy noodle&quot;</em>.</p><h5 id="dialog-acts" tabindex="-1">Dialog acts <a class="header-anchor" href="#dialog-acts" aria-label="Permalink to &quot;Dialog acts&quot;">​</a></h5><p>Dialog act is another CUI data type in OpenCUI and is designed to help map structured meaning back to natural text.</p><h5 id="entities" tabindex="-1">Entities <a class="header-anchor" href="#entities" aria-label="Permalink to &quot;Entities&quot;">​</a></h5><p>Entity is your primitive type in OpenCUI, and it is basic building block for complex data type. Entity type can have subtypes. For example, cell phone models could be partitioned into feature phone and smartphone, and smartphone can be further partitioned to iPhone and android phones.</p><p>For each entity type, there are many entity entries. Each entity entry provides a set of expressions that are considered to be trigger for that entry, or when one of expression is mentioned, we consider user prefer the corresponding entry.</p><h4 id="annotations" tabindex="-1">Annotations <a class="header-anchor" href="#annotations" aria-label="Permalink to &quot;Annotations&quot;">​</a></h4><p>After these types are defined at schema level, builder can add annotation on top of it to control the every aspect of this component. An example will be what if a user did not specify a value for a required slot, how do we prompt them in a given language.</p><h5 id="dialog-annotations" tabindex="-1">Dialog annotations <a class="header-anchor" href="#dialog-annotations" aria-label="Permalink to &quot;Dialog annotations&quot;">​</a></h5><p>In cases where users do not provide all the information needed in a single utterance, you need to design a conversation to help chatbot get the user&#39;s preference for a given option. This can be done in OpenCUI by adding various dialog annotations.</p><p>Dialog annotations can be defined both on slot and type level. Slot level annotations defines how individual slot can be filled. This includes whether the slot can take multiple values, whether it needs confirmation. For frame slot, whether the polymorphism is allowed. Type level annotations are related to multi-slot filling where values for slots need to collectively make business sense. This includes annotations like value recommendations and value check. Value recommendation provides a user with candidate list so that they can pick one from that instead of input something that is invalid. Value check makes sure agent catch user input error as early as possible so that conversation can be efficient. Dialog annotations are naturally separated into interaction related and language related, each can be handled by different set of people. This makes multiple language support easy.</p><h5 id="backend-annotations" tabindex="-1">Backend annotations <a class="header-anchor" href="#backend-annotations" aria-label="Permalink to &quot;Backend annotations&quot;">​</a></h5><p>OpenCUI allow you to build hosted SQL provider declaratively using annotations and SQL.</p><ul><li>Declare all data types first required the service APIs and their implementation helper functions;</li><li>Add storage annotation to help OpenCUI infer corresponding table schema;</li><li>Use SQL to implement the service APIs;</li><li>Add backoffice annotation to define admin interface, including look and feel, and input mode.</li></ul><p>Once you have decided on the data frame that you want to persist, you can simply turn on the storage annotation for that frame. When the storage annotation is turned on for a frame, OpenCUI will automatically create a corresponding table with each slot mapped to a column in the hosting database. You can precisely control how these columns are created, using annotations such as:</p><ul><li>Not Null: indicates whether a column can host a null value;</li><li>Default Value: defines the default value for the column;</li><li>Unique: indicates whether a value in the column needs to be unique and can potentially serve as a key.</li></ul><p>The data in these tables also needs to be accessed and manipulated by your operations team. For the SQL provider, they can do so through a web interface called &quot;back office&quot;. The back office is automatically created based on the back office annotation, and its user experience can be controlled by annotations such as:</p><ul><li>Sortable: indicating whether one can sort the entire table by the given column.</li><li>Input Mode: determining whether a dropdown menu can be used for inputting this column and specifying the available choices.</li></ul>',43),r=[s];function l(c,d,h,p,u,m){return n(),a("div",null,r)}const g=t(i,[["render",l]]);export{y as __pageData,g as default};
